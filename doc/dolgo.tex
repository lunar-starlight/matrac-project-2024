\documentclass{article}
\usepackage{unicode-math}
\usepackage{enumerate}
\usepackage[backend=biber]{biblatex}
\bibliography{bibliografija.bib}
\def\generic{\texttt{generic}}
\def\natrec{\texttt{natrec}}
\def\boolrec{\texttt{boolrec}}
\def\zero{\texttt{zero}}
\def\suc{\texttt{succ}}
\begin{document}

\section{Mathematical preliminaries}
The idea is to show that every System T definable functional \(2^ℕ → 2\) is
continuous (under the usual compact-open topology).

\subsection{System T}
System T was introduced by Kurt Gödel in 1958 for the purposes of the so-called
Dialectica interpretation\cite{dialectica}. It has multiple presentations, but it is essentially
a typed lambda calculus with a natural numbers type (denoted \(N\)).

We read the sequent \(Γ ⊢ t : T\) as ``in the context \(Γ\), the term \(t\) (is
well-formed and) has type \(T\)'', where a context is a list of variables and
their types. If the context is not relevant I will ommit it.

Specifically we have the following term forming rules:
\begin{itemize}
\item Variables: We have an infinite set of variables, usually denoted by \(x\),
  \(y\), … They form terms \(Γ, x : A ⊢ x : A\).
\item Lambda abstraction: For each term \(Γ, x : A ⊢ t : B\) we have a term
  \(Γ ⊢ λx. t : A → B\).
\item Application: For terms \(t : A → B\) and \(u : A\) we have a term \(t(u) : B\).
\item Zero: \(\zero : N\) is a term.
\item Successor: For each term \(t : N\) we have it's successor \(\suc(t) : N\).
\item Induction principle: For terms \(t₀ : B\) (base case), \({tₛ : N → B → B}\)
  (successor case), and natural number term \(t : N\) we have the term
  \({\natrec(t₀, tₛ, t) : B}\), which is obtained by induction on \(t\).
\end{itemize}

This can be extended by adding boolean values (and a boolean induction
principle) without changing the expressive strength of the system, since we can
encode booleans in the natural numbers.
This will be useful for talking about the functionals we are interested in.

The computaton rules are fairly standard for a call-by-name lambda calculus:
\begin{itemize}
\item For application, if the first term can make a step we make it, otherwise
  we substitute the second term.
\item For the successor, if the term inside can make a step we make it.
\item For induction, if the term we are doing induction on can step we make it,
  otherwise it's either zero or a successor, so we can step into the base or
  successor cases respectively.
\item For induction on booleans the same as above, except we compute to true
  or false, in which case we apply the true or false case repsectively.
\end{itemize}


\subsection{Topology}
The space \(2^ℕ\) is called the Cantor space. With the compact-open topology
it is homeomorphic to the Cantor set as a subspace of the real numbers.
It is useful to think of elements of \(2^ℕ\) as infinite sequences of zeroes and
ones. Then the open sets are generated by a subbasis of sets of functions that
map \(n ∈ ℕ\) to \(b ∈ 2\), for all possible values of \(n\) and \(b\).
%In particular we have a basis formed by (finite) prefixes (indexed by all finite
%words on \(2\)), and every open set can be partitioned into basic opens.

Continuity of a functional \(F : 2^ℕ → 2\) now means that the preimage of
\(b ∈ 2\) under \(F\) is an open set.
This means that for every \(α ∈ 2^ℕ\) exists some basic open neighbourhood \(U ∋ α\),
such that \(F\) maps it into \(F(α)\). But this then means that there must be
some \(k ∈ ℕ\) such that if any \(β\) agrees with \(α\) in the first \(k\) places,
then \(F\) must map them to the same value.

In fact this can be done uniformly, since \(2^ℕ\) is compact.

\subsection{Forcing}
The basic idea of forcing is to add a new ``generic'' element to some model,
such that it can represent an arbitrary element of some set.
In our case we wish to add a constructor \(\generic : N → B\) to System T.

Now we need to extend evaluation of the System T, to handle the new constructor.
For this purpose we will introduce an evaluation context which we call a
condition set. It is a set of pairs of natural numbers and booleans, which will
serve as a lookup table for the applications of the generic element.

So for example, if we have the condition set \(\{(1, 0)\}\), then
\(\generic(1)\) should evaluate to \(0\). Now we just need to consider what should
happen if the argument to \(\generic\) is not present in the condition set.
Intuitively, if we want it to behave as a generic element, we should be able to
inspect both branches of evaluation. We can handle this by splitting our
condition set by adding the conditions \((n, 0)\) and \((n, 1)\) to each of the
branches, and then continue to evaluate both branches. To keep track of
branches, we can say that if we have \(p ⊩ \generic(n)\), and \(n\) is not in the
condition set, evaluate the expression to a formal sum \(p₀ ⊩ 0 + p₁ ⊩ 1\).
In general, if \(pᵢ\) is some partition of \(p\), and \(t\) evaluates to \(tᵢ\)
on those partitions, then \(p ⊩ t\) evaluates to \(∑ᵢ pᵢ ⊩ tᵢ\).

\subsection{The proof}
The idea of the proof is as follows.
Suppose we have a System T defined functional \(F\). Then we evaluate it on the
generic element in an empty context. By some lemmas we can show this has a
normal form, which means it evaluates to some formal sum \(∑ᵢ pᵢ ⊩ bᵢ\), where
\(bᵢ\) are canonical elements of the type \(B\). Now we can inspect the \(pᵢ\)
and extract the largest natural number that occurs in any of the condition sets.
This gives us the largest argument that the functional \(F\) can possibly
evaluate, so it is the modulus of continuity for \(F\).

\section{Formalization of sheaf forcing}

I have not yet found a satisfying solution to the issues at hand.
The partitions have a natural tree structure, but if I define them like trees I
can't index over the elements of the partition, which becomes a problem.

I expect to solve this to some extent in the coming weeks, but for now I can't
write anything here.

\subsection{System T}
Currently I have implemented System T as an ordinary typed lambda calculus with
two inductive types: the natural numbers and the booleans. One possible
simplification is to define it as an \(\mathrm{SK}\) calculus (with those same
types), as is done in\cite{dialogue}, but I personally prefer the lambda
calculus.
Currently the lambda calculus uses call-by-name semantics, though using
fine-grained call-by-value semantics seem like a significant improvement.
However, often the biggest issue in proving theorems is substitutions, and
fine-grained call-by-value semantics don't help with that.

\subsection{Cantor space}
There is actually no definition of the Cantor space or its opens in the project.
This is because we have extracted the essence of the continuity the space
provides with regards to forcing, and now represent it with condition sets and
their partitions. Currently these are defined as lists of number-boolean pairs
and trees respectively.

The definition of condition sets is quite adequate, insofar as I have never had
to explicitly manipulate them, but the definition of partitions is lacking. The
tree structure imposes a tree structure to the computation of normal forms,
which is probably undesirable. More importantly though, the tree structure does
not expose any way to allow me to talk about for example terms \(tᵢ\) for every
\(pᵢ\) in the partition. Further work is needed to verify whether it is possible
to also encode the partitions as finite lists, and to find a way to reasonably
iterate over them.

There is some concern that this will still produce inadequate results because
lists are ordered, but this has not been an issue for condition sets, and I hope
it will not be an issue for the partitions either.

\section{Goals}

In the beginning I had the following checkpoints in mind:
\begin{enumerate}[(1)]
	\item\label{cat} Define the category of sheaves over $2^ℕ$
	\item\label{forcing} Define sheaf forcing
	\item\label{syst} Define/interpret Gödel's System T
	\item\label{cont} Show that System T definable $2^ℕ → ℕ$ functions are uniformly continuous
	\item\label{baire} Extend \ref{cat} and \ref{forcing} to $ℕ^ℕ$
	\item Show the proof of \ref{cont} doesn't apply to \ref{baire}
	\item Prove \ref{cont} for \ref{baire} in the non-uniform case
\end{enumerate}

Trying to define the category is too difficult, but \ref{syst} didn't present
any issues, though an alternative approach might have been better. As mentioned
above, defining sheaf forcing is currently a significant issue, however I have
written down the proof/algorithm that computes the modulus of continuity,
assuming I can formulate forcing in such a way that allows me to compute normal
forms.

Since I've already encountered significant difficulties and have spent a
sufficient amount of time on the binary case I will not attempt to complete
the three checkpoints.

Since \ref{cont} is mostly finished, up to renaming or relabeling of variables,
I will set just the checkpoints \ref{forcing}, \ref{syst}, and \ref{cont} as my
goal. I sincerely hope to complete this by the defense date.

\printbibliography
\end{document}
