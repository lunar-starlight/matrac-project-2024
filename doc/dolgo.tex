\documentclass{article}
\usepackage{unicode-math}
\usepackage{enumerate}
\usepackage[backend=biber]{biblatex}
\bibliography{bibliografija.bib}
\def\generic{\texttt{generic}}
\def\natrec{\texttt{natrec}}
\def\boolrec{\texttt{boolrec}}
\begin{document}

\section{Mathematical preliminaries}

The idea is to show that every System T definable functional \(2^ℕ → 2\) is
continuous (under the usual compact-open topology).

\subsection{System T}
System T was introduced by Kurt Gödel in TODO: year and citation. It has
multiple presentations, but it is essentially a typed lambda calculus with a
natural numbers type (denoted \(N\)). Specifically we have the following term forming rules:
\begin{itemize}
\item Variables: We have an infinite set of variables, usually denoted by \(x\),
  \(y\), … They form terms \(Γ, x : A ⊢ x : A\).
\item Lambda abstraction: For each term \(Γ, x : A ⊢ t : B\) we have a term
  \(Γ ⊢ λx. t : A → B\).
\item Application: For terms \(t : A → B\) and \(u : A\) we have a term \(t(u) : B\).
\item Zero: \(0 : N\) is a term.
\item Successor: For each term \(t : N\) we have it's successor \(succ(t) : N\).
\item Induction principle: For terms \(t₀ : B\) (base case), \({tₛ : N → B → B}\)
  (successor case), and natural number term \(t : N\) we have the term
  \({\natrec(t₀, tₛ, t) : B}\), which is obtained by induction on \(t\).
\end{itemize}

This can be extended by adding boolean values (and a boolean induction
principle) without changing the expressive strength of the system, since we can
encode booleans in the natural numbers.
This will be useful for talking about the functionals we are interested in.

\subsection{Topology}
The space \(2^ℕ\) is called the Cantor space. With the compact-open topology
it is homeomorphic to the Cantor set as a subspace of the real numbers.
It is useful to think of elements of \(2^ℕ\) as infinite sequences of zeroes and
ones. Then the open sets are generated by a subbasis of sets of functions that
map \(n ∈ ℕ\) to \(b ∈ 2\), for all possible values of \(n\) and \(b\).
%In particular we have a basis formed by (finite) prefixes (indexed by all finite
%words on \(2\)), and every open set can be partitioned into basic opens.

Continuity of a functional \(F : 2^ℕ → 2\) now means that the preimage of
\(b ∈ 2\) under \(F\) is an open set.
This means that for every \(α ∈ 2^ℕ\) exists some basic open neighbourhood \(U ∋ α\),
such that \(F\) maps it into \(F(α)\). But this then means that there must be
some \(k ∈ ℕ\) such that if any \(β\) agrees with \(α\) in the first \(k\) places,
then \(F\) must map them to the same value.

In fact this can be done uniformly, since \(2^ℕ\) is compact.

\subsection{Forcing}
The basic idea of forcing is to add a new ``generic'' element to some model,
such that it can represent an arbitrary element of some set.
In our case we wish to add a constructor \(\generic : N → B\) to System T.

Now we need to extend evaluation of the System T, to handle the new constructor.
For this purpose we will introduce an evaluation context which we call a
condition set. It is a set of pairs of natural numbers and booleans, which will
serve as a lookup table for the applications of the generic element.

So for example, if we have the condition set \(\{(1, 0)\}\), then
\(\generic(1)\) should evaluate to \(0\). Now we just need to consider what should
happen if the argument to \(\generic\) is not present in the condition set.
Intuitively, if we want it to behave as a generic element, we should be able to
inspect both branches of evaluation. We can handle this by splitting our
condition set by adding the conditions \((n, 0)\) and \((n, 1)\) to each of the
branches, and then continue to evaluate both branches. To keep track of
branches, we can say that if we have \(p ⊩ generic(n)\), and \(n\) is not in the
condition set, evaluate the expression to a formal sum \(p₀ ⊩ 0 + p₁ ⊩ 1\).
In general, if \(pᵢ\) is some partition of \(p\), and \(t\) evaluates to \(tᵢ\)
on those partitions, then \(p ⊩ t\) evaluates to \(∑ᵢ pᵢ ⊩ tᵢ\).

\subsection{The proof}

The idea of the proof is as follows.
Suppose we have a System T defined functional \(F\). Then we evaluate it on the
generic element in an empty context. By some lemmas we can show this has a
normal form, which means it evaluates to some formal sum \(∑ᵢ pᵢ ⊩ bᵢ\), where
\(bᵢ\) are canonical elements of the type \(B\). Now we can inspect the \(pᵢ\)
and extract the largest natural number that occurs in any of the condition sets.
This gives us the largest argument that the functional \(F\) can possibly
evaluate, so it is the modulus of continuity for \(F\).

\section{Formalization of sheaf forcing}






\section{Goals}

I have the following checkpoints in mind, and they may also serve as good endpoints for the project,
depending on how much time it will take to complete:
\begin{enumerate}[(1)]
	\item\label{cat} Define the category of sheaves over $2^ℕ$
	\item\label{forcing} Define sheaf forcing
	\item\label{syst} Define/interpret Gödel's System T
	\item\label{cont} Show that System T definable $2^ℕ → ℕ$ functions are uniformly continuous
	\item\label{baire} Extend \ref{cat} and \ref{forcing} to $ℕ^ℕ$
	\item Show the proof of \ref{cont} doesn't apply to \ref{baire}
	\item Prove \ref{cont} for \ref{baire} in the non-uniform case
\end{enumerate}

I plan to use the libraries agda-stdlib\cite{stdlib}, agda-categories\cite{catlib}, and also TypeTopology\cite{tytop} if absolutely necessary.

In case there are significant issues to defining the category itself,
I will attempt to directly describe forcing without mentioning sheaves,
as is (I believe) done in \cite{coquand}.

The description of the objects of interest in the Cantor space case is sufficiently finite
(it is precisely finite binary trees), so that computers can easily compute with them,
however the Baire space the trees are not finitely branching
(there is a branch for each natural number) so I believe more care needs
to be taken to define them correctly.

\printbibliography
\end{document}
